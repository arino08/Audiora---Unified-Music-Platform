{"ast":null,"code":"import _asyncToGenerator from \"/home/ariz/DEV/Audiora/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"/home/ariz/DEV/Audiora/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { signal } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nexport let PlayerService = /*#__PURE__*/(() => {\n  var _PlayerService;\n  class PlayerService {\n    constructor() {\n      _defineProperty(this, \"current\", signal(null));\n      _defineProperty(this, \"isPlaying\", signal(false));\n      // simple queue\n      _defineProperty(this, \"queue\", signal([]));\n      // active provider convenience\n      _defineProperty(this, \"activeProvider\", signal(null));\n      _defineProperty(this, \"endTimer\", void 0);\n      _defineProperty(this, \"LS_KEY\", 'audiora_last_played');\n      // callbacks for integration (set by host component)\n      _defineProperty(this, \"onSpotifyPlay\", void 0);\n      _defineProperty(this, \"onSpotifyPause\", void 0);\n      _defineProperty(this, \"onYouTubePlay\", void 0);\n      _defineProperty(this, \"onYouTubeStop\", void 0);\n      // Restore last played (not auto-playing) if available\n      try {\n        const raw = localStorage.getItem(this.LS_KEY);\n        if (raw) {\n          const parsed = JSON.parse(raw);\n          if (parsed && parsed.provider && parsed.title) {\n            this.current.set(parsed);\n            this.activeProvider.set(parsed.provider);\n            this.isPlaying.set(false);\n          }\n        }\n      } catch {}\n    }\n    setCallbacks(cb) {\n      if (cb.onSpotifyPlay) this.onSpotifyPlay = cb.onSpotifyPlay;\n      if (cb.onSpotifyPause) this.onSpotifyPause = cb.onSpotifyPause;\n      if (cb.onYouTubePlay) this.onYouTubePlay = cb.onYouTubePlay;\n      if (cb.onYouTubeStop) this.onYouTubeStop = cb.onYouTubeStop;\n    }\n    play(_x) {\n      var _this = this;\n      return _asyncToGenerator(function* (item, append = false) {\n        if (append && _this.current()) {\n          _this.queue.update(q => [...q, item]);\n          return;\n        }\n        // switching provider? stop other\n        if (_this.activeProvider() && _this.activeProvider() !== item.provider) {\n          yield _this.pause(); // pause current first\n        }\n        // clear any previous end timer\n        if (_this.endTimer) {\n          clearTimeout(_this.endTimer);\n          _this.endTimer = null;\n        }\n        let ok = false;\n        if (item.provider === 'spotify' && _this.onSpotifyPlay) {\n          ok = yield _this.onSpotifyPlay(item);\n        } else if (item.provider === 'youtube' && _this.onYouTubePlay) {\n          ok = yield _this.onYouTubePlay(item);\n        }\n        if (ok) {\n          _this.current.set(item);\n          _this.activeProvider.set(item.provider);\n          _this.isPlaying.set(true);\n          // persist last played\n          try {\n            localStorage.setItem(_this.LS_KEY, JSON.stringify(item));\n          } catch {}\n          // schedule auto-advance for known-duration items (e.g., Spotify)\n          const duration = item.durationMs;\n          if (item.provider === 'spotify' && duration && duration > 0) {\n            // add slight buffer (500ms) to ensure track truly ended\n            _this.endTimer = setTimeout(() => {\n              _this.next();\n            }, duration + 500);\n          }\n        }\n      }).apply(this, arguments);\n    }\n    pause() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.current()) return;\n        if (_this2.endTimer) {\n          clearTimeout(_this2.endTimer);\n          _this2.endTimer = null;\n        }\n        if (_this2.activeProvider() === 'spotify' && _this2.onSpotifyPause) {\n          yield _this2.onSpotifyPause();\n        } else if (_this2.activeProvider() === 'youtube' && _this2.onYouTubeStop) {\n          yield _this2.onYouTubeStop();\n        }\n        _this2.isPlaying.set(false);\n      })();\n    }\n    next() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (_this3.endTimer) {\n          clearTimeout(_this3.endTimer);\n          _this3.endTimer = null;\n        }\n        const q = _this3.queue();\n        if (q.length === 0) {\n          // nothing queued\n          yield _this3.pause();\n          _this3.current.set(null);\n          _this3.activeProvider.set(null);\n          return;\n        }\n        const [head, ...rest] = q;\n        _this3.queue.set(rest);\n        yield _this3.play(head, false);\n      })();\n    }\n    clearQueue() {\n      this.queue.set([]);\n    }\n    // External providers can notify explicit end (e.g., YouTube ended event)\n    notifyEnded() {\n      // If a timer is present (Spotify scheduling) clear it to avoid duplicate next\n      if (this.endTimer) {\n        clearTimeout(this.endTimer);\n        this.endTimer = null;\n      }\n      this.next();\n    }\n  }\n  _PlayerService = PlayerService;\n  _defineProperty(PlayerService, \"\\u0275fac\", function PlayerService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PlayerService)();\n  });\n  _defineProperty(PlayerService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _PlayerService,\n    factory: _PlayerService.ɵfac,\n    providedIn: 'root'\n  }));\n  return PlayerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}