{"ast":null,"code":"import _asyncToGenerator from \"/home/ariz/DEV/Audiora/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"/home/ariz/DEV/Audiora/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { signal, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { AuthService } from './auth.service';\nimport * as i0 from \"@angular/core\";\nexport let LikedSongsService = /*#__PURE__*/(() => {\n  var _LikedSongsService;\n  class LikedSongsService {\n    constructor() {\n      _defineProperty(this, \"STORAGE_KEY\", 'audiora_liked_songs');\n      _defineProperty(this, \"http\", inject(HttpClient));\n      _defineProperty(this, \"auth\", inject(AuthService));\n      _defineProperty(this, \"backendBase\", `http://${window.location.hostname}:8080`);\n      // Signal for reactive UI updates\n      _defineProperty(this, \"likedTracks\", signal([]));\n      this.loadFromStorage();\n      // Watch for authentication changes\n      this.setupAuthWatcher();\n    }\n    setupAuthWatcher() {\n      // Use effect to watch auth state changes\n      // When user logs in, sync local tracks to server\n      // When user logs out, clear server tracks and use local only\n      // This is a simplified approach - in production you'd want more sophisticated syncing\n      setTimeout(() => {\n        if (this.auth.isAuthenticated()) {\n          this.syncToServer();\n        }\n      }, 100);\n    }\n    loadFromStorage() {\n      try {\n        const stored = localStorage.getItem(this.STORAGE_KEY);\n        if (stored) {\n          const tracks = JSON.parse(stored).map(track => ({\n            ...track,\n            likedAt: new Date(track.likedAt)\n          }));\n          this.likedTracks.set(tracks);\n        }\n      } catch (error) {\n        console.warn('Failed to load liked songs from storage:', error);\n        this.likedTracks.set([]);\n      }\n    }\n    saveToStorage() {\n      try {\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.likedTracks()));\n      } catch (error) {\n        console.warn('Failed to save liked songs to storage:', error);\n      }\n    }\n    isLiked(trackId, provider) {\n      return this.likedTracks().some(track => track.id === trackId && track.provider === provider);\n    }\n    toggleLike(track, provider) {\n      const trackId = this.getTrackId(track, provider);\n      const isCurrentlyLiked = this.isLiked(trackId, provider);\n      if (isCurrentlyLiked) {\n        this.removeLike(trackId, provider);\n        return false;\n      } else {\n        this.addLike(track, provider);\n        return true;\n      }\n    }\n    addLike(track, provider) {\n      const likedTrack = {\n        id: this.getTrackId(track, provider),\n        provider,\n        title: this.getTrackTitle(track, provider),\n        artist: this.getTrackArtist(track, provider),\n        album: this.getTrackAlbum(track, provider),\n        image: this.getTrackImage(track, provider),\n        likedAt: new Date()\n      };\n      if (provider === 'spotify') {\n        likedTrack.uri = track.uri;\n        likedTrack.durationMs = track.durationMs || track.duration_ms;\n      } else if (provider === 'youtube') {\n        likedTrack.videoId = track.videoId || track.id;\n      }\n      const currentTracks = this.likedTracks();\n      this.likedTracks.set([likedTrack, ...currentTracks]);\n      this.saveToStorage();\n    }\n    removeLike(trackId, provider) {\n      const currentTracks = this.likedTracks();\n      const filtered = currentTracks.filter(track => !(track.id === trackId && track.provider === provider));\n      this.likedTracks.set(filtered);\n      this.saveToStorage();\n    }\n    getTrackId(track, provider) {\n      if (provider === 'spotify') {\n        return track.track?.id || track.id;\n      } else {\n        return track.videoId || track.id;\n      }\n    }\n    getTrackTitle(track, provider) {\n      if (provider === 'spotify') {\n        return track.track?.name || track.name || 'Unknown Track';\n      } else {\n        return track.title || 'Unknown Track';\n      }\n    }\n    getTrackArtist(track, provider) {\n      if (provider === 'spotify') {\n        const artists = track.track?.artists || track.artists;\n        return Array.isArray(artists) ? artists.join(', ') : 'Unknown Artist';\n      } else {\n        return track.channel || 'YouTube';\n      }\n    }\n    getTrackAlbum(track, provider) {\n      if (provider === 'spotify') {\n        return track.track?.album || track.album;\n      }\n      return undefined;\n    }\n    getTrackImage(track, provider) {\n      if (provider === 'spotify') {\n        return track.track?.image || track.image;\n      } else {\n        return track.thumbnail || track.image;\n      }\n    }\n    getLikedTracksByProvider(provider) {\n      return this.likedTracks().filter(track => track.provider === provider);\n    }\n    clearAllLikes() {\n      this.likedTracks.set([]);\n      this.saveToStorage();\n    }\n    exportLikes() {\n      return JSON.stringify(this.likedTracks(), null, 2);\n    }\n    importLikes(jsonData) {\n      try {\n        const tracks = JSON.parse(jsonData).map(track => ({\n          ...track,\n          likedAt: new Date(track.likedAt)\n        }));\n        this.likedTracks.set(tracks);\n        this.saveToStorage();\n        return true;\n      } catch (error) {\n        console.error('Failed to import likes:', error);\n        return false;\n      }\n    }\n    // Server synchronization methods\n    syncToServer() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.auth.isAuthenticated()) return;\n        const userId = _this.auth.userId();\n        if (!userId) return;\n        try {\n          // First, get current server tracks\n          const serverTracks = yield _this.fetchServerTracks(userId);\n          // Import local tracks to server if user has local tracks\n          const localTracks = _this.likedTracks();\n          if (localTracks.length > 0) {\n            yield _this.importTracksToServer(userId, localTracks);\n            // After successful import, clear local storage\n            localStorage.removeItem(_this.STORAGE_KEY);\n          }\n          // Refresh from server\n          yield _this.loadFromServer(userId);\n        } catch (error) {\n          console.error('Failed to sync to server:', error);\n        }\n      })();\n    }\n    fetchServerTracks(userId) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const response = yield _this2.http.get(`${_this2.backendBase}/api/users/${userId}/liked-tracks`).toPromise();\n        return response?.map(track => ({\n          id: track.trackId,\n          provider: track.provider.toLowerCase(),\n          title: track.title,\n          artist: track.artist,\n          album: track.album,\n          image: track.imageUrl,\n          uri: track.provider === 'SPOTIFY' ? `spotify:track:${track.trackId}` : undefined,\n          videoId: track.provider === 'YOUTUBE' ? track.trackId : undefined,\n          likedAt: new Date(track.likedAt)\n        })) || [];\n      })();\n    }\n    loadFromServer(userId) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const serverTracks = yield _this3.fetchServerTracks(userId);\n          _this3.likedTracks.set(serverTracks);\n        } catch (error) {\n          console.error('Failed to load from server:', error);\n        }\n      })();\n    }\n    importTracksToServer(userId, tracks) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const importData = tracks.map(track => ({\n          provider: track.provider.toUpperCase(),\n          trackId: track.provider === 'spotify' ? track.id : track.videoId || track.id,\n          title: track.title,\n          artist: track.artist,\n          album: track.album,\n          imageUrl: track.image,\n          externalUrl: track.uri || (track.videoId ? `https://youtube.com/watch?v=${track.videoId}` : undefined),\n          likedAt: track.likedAt.toISOString()\n        }));\n        yield _this4.http.post(`${_this4.backendBase}/api/users/${userId}/liked-tracks/import`, importData).toPromise();\n      })();\n    }\n    toggleLikeServer(track, provider) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this5.auth.isAuthenticated()) {\n          // Fall back to local storage\n          return _this5.toggleLike(track, provider);\n        }\n        const userId = _this5.auth.userId();\n        if (!userId) return false;\n        const trackId = provider === 'spotify' ? track.id : track.videoId || track.id;\n        const isCurrentlyLiked = _this5.isLiked(trackId, provider);\n        try {\n          if (isCurrentlyLiked) {\n            // Unlike on server\n            yield _this5.http.delete(`${_this5.backendBase}/api/users/${userId}/liked-tracks/${provider.toUpperCase()}/${trackId}`).toPromise();\n          } else {\n            // Like on server\n            const likeRequest = {\n              provider: provider.toUpperCase(),\n              trackId: trackId,\n              title: track.name || track.title,\n              artist: provider === 'spotify' ? track.artists?.[0]?.name : track.artist,\n              album: track.album?.name || track.album,\n              imageUrl: provider === 'spotify' ? track.album?.images?.[0]?.url : track.image,\n              externalUrl: provider === 'spotify' ? track.external_urls?.spotify : `https://youtube.com/watch?v=${track.videoId}`\n            };\n            yield _this5.http.post(`${_this5.backendBase}/api/users/${userId}/liked-tracks`, likeRequest).toPromise();\n          }\n          // Refresh from server\n          yield _this5.loadFromServer(userId);\n          return !isCurrentlyLiked;\n        } catch (error) {\n          console.error('Failed to toggle like on server:', error);\n          // Fall back to local storage\n          return _this5.toggleLike(track, provider);\n        }\n      })();\n    }\n    // Method to manually trigger sync (for UI button)\n    manualSync() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        if (_this6.auth.isAuthenticated()) {\n          yield _this6.syncToServer();\n        }\n      })();\n    }\n  }\n  _LikedSongsService = LikedSongsService;\n  _defineProperty(LikedSongsService, \"\\u0275fac\", function LikedSongsService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LikedSongsService)();\n  });\n  _defineProperty(LikedSongsService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _LikedSongsService,\n    factory: _LikedSongsService.ɵfac,\n    providedIn: 'root'\n  }));\n  return LikedSongsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}