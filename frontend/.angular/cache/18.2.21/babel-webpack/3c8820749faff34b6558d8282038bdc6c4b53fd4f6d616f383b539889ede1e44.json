{"ast":null,"code":"import * as rs from 'jsrsasign';\nimport { AbstractValidationHandler } from 'angular-oauth2-oidc';\n\n/**\n * Validates the signature of an id_token against one\n * of the keys of an JSON Web Key Set (jwks).\n *\n * This jwks can be provided by the discovery document.\n */\nclass JwksValidationHandler extends AbstractValidationHandler {\n  constructor() {\n    super(...arguments);\n    /**\n     * Allowed algorithms\n     */\n    this.allowedAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n    /**\n     * Time period in seconds the timestamp in the signature can\n     * differ from the current time.\n     */\n    this.gracePeriodInSec = 600;\n  }\n  validateSignature(params, retry = false) {\n    if (!params.idToken) throw new Error('Parameter idToken expected!');\n    if (!params.idTokenHeader) throw new Error('Parameter idTokenHandler expected.');\n    if (!params.jwks) throw new Error('Parameter jwks expected!');\n    if (!params.jwks['keys'] || !Array.isArray(params.jwks['keys']) || params.jwks['keys'].length === 0) {\n      throw new Error('Array keys in jwks missing!');\n    }\n    // console.debug('validateSignature: retry', retry);\n    let kid = params.idTokenHeader['kid'];\n    let keys = params.jwks['keys'];\n    let key;\n    let alg = params.idTokenHeader['alg'];\n    if (kid) {\n      key = keys.find(k => k['kid'] === kid /* && k['use'] === 'sig' */);\n    } else {\n      let kty = this.alg2kty(alg);\n      let matchingKeys = keys.filter(k => k['kty'] === kty && k['use'] === 'sig');\n      /*\n            if (matchingKeys.length == 0) {\n                let error = 'No matching key found.';\n                console.error(error);\n                return Promise.reject(error);\n            }*/\n      if (matchingKeys.length > 1) {\n        let error = 'More than one matching key found. Please specify a kid in the id_token header.';\n        console.error(error);\n        return Promise.reject(error);\n      } else if (matchingKeys.length === 1) {\n        key = matchingKeys[0];\n      }\n    }\n    if (!key && !retry && params.loadKeys) {\n      return params.loadKeys().then(loadedKeys => params.jwks = loadedKeys).then(_ => this.validateSignature(params, true));\n    }\n    if (!key && retry && !kid) {\n      let error = 'No matching key found.';\n      console.error(error);\n      return Promise.reject(error);\n    }\n    if (!key && retry && kid) {\n      let error = 'expected key not found in property jwks. ' + 'This property is most likely loaded with the ' + 'discovery document. ' + 'Expected key id (kid): ' + kid;\n      console.error(error);\n      return Promise.reject(error);\n    }\n    let keyObj = rs.KEYUTIL.getKey(key);\n    let validationOptions = {\n      alg: this.allowedAlgorithms,\n      gracePeriod: this.gracePeriodInSec\n    };\n    let isValid = rs.KJUR.jws.JWS.verifyJWT(params.idToken, keyObj, validationOptions);\n    if (isValid) {\n      return Promise.resolve();\n    } else {\n      return Promise.reject('Signature not valid');\n    }\n  }\n  alg2kty(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        return 'RSA';\n      case 'E':\n        return 'EC';\n      default:\n        throw new Error('Cannot infer kty from alg: ' + alg);\n    }\n  }\n  calcHash(valueToHash, algorithm) {\n    let hashAlg = new rs.KJUR.crypto.MessageDigest({\n      alg: algorithm\n    });\n    let result = hashAlg.digestString(valueToHash);\n    let byteArrayAsString = this.toByteArrayAsString(result);\n    return Promise.resolve(byteArrayAsString);\n  }\n  toByteArrayAsString(hexString) {\n    let result = '';\n    for (let i = 0; i < hexString.length; i += 2) {\n      let hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\n      let num = parseInt(hexDigit, 16);\n      result += String.fromCharCode(num);\n    }\n    return result;\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JwksValidationHandler };\n//# sourceMappingURL=angular-oauth2-oidc-jwks.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}